<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Apoorv's Blog</title><link href="http://nerdap.github.io/" rel="alternate"></link><link href="http://nerdap.github.io/feeds/gsoc-2013.atom.xml" rel="self"></link><id>http://nerdap.github.io/</id><updated>2013-10-01T10:42:00+05:30</updated><entry><title>GSoC End Term Review</title><link href="http://nerdap.github.io/gsoc-2013-finishing-up.html" rel="alternate"></link><updated>2013-10-01T10:42:00+05:30</updated><author><name>Apoorv Upreti</name></author><id>tag:nerdap.github.io,2013-10-01:gsoc-2013-finishing-up.html</id><summary type="html">&lt;p&gt;GSoC officially ended on the 27th of this month. I've been a little late in finishing this blog post because I had exams from the 28th.&lt;/p&gt;
&lt;p&gt;Since this is probably my final GSoC blog post, I'm going to discuss how to setup and try out the test harness so members of the SDL community can use the test harness themselves and give comments or suggestions.&lt;/p&gt;
&lt;h3&gt;What we have so far&lt;/h3&gt;
&lt;p&gt;We've got a test harness that can run a system under test (SUT) executable for various combinations of command line parameters, take screenshots of the SUT windows and compare these screenshots with a repository of verification images.&lt;/p&gt;
&lt;p&gt;I've made available verification images for two configs that you can find below.&lt;/p&gt;
&lt;h3&gt;Trying out the automated testing&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Start off by cloning the &lt;a href="https://bitbucket.org/nerdap/sdlvisualtest"&gt;repository&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Build using the instructions in &lt;code&gt;visualtest/README.txt&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If you're using the Makefile to build, copy &lt;code&gt;testsprite2&lt;/code&gt; and &lt;code&gt;icon.bmp&lt;/code&gt; to the test harness executable directory. The VS solution does this automatically.&lt;/li&gt;
&lt;li&gt;Download the verification images for one of the configs:&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.dropbox.com/s/nm02aem76m812ng/testsprite2_blendmodes.zip"&gt;testsprite2_blendmodes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.dropbox.com/s/csypwryopaslpaf/testsprite2_geometry.zip"&gt;testsprite2_geometry&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Extract the directory of verification images. The path to this directory should be passed to the test harness as &lt;code&gt;verify_dir&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Copy the &lt;code&gt;*.config&lt;/code&gt;, &lt;code&gt;*.parameters&lt;/code&gt; and &lt;code&gt;*.actions&lt;/code&gt; files to the test harness executable directory.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;testharness --config testsprite2_XXX.config --verify-dir /path/to/verify_dir&lt;/code&gt;, where &lt;code&gt;testsprite2_XXX.config&lt;/code&gt; is the name of the config file you want to use.&lt;/li&gt;
&lt;li&gt;If all goes well, all tests should pass and you should get a message like "X/X tests passed".&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That's about it. If any of the tests fail, do let me know. Take a look at &lt;code&gt;README.txt&lt;/code&gt; for more detailed usage instructions and contact information.&lt;/p&gt;
&lt;h3&gt;What's next&lt;/h3&gt;
&lt;p&gt;Lots of tasks still remain. A more complete list is in README.txt, which I'll keep updating as time goes on. At the moment, the following are priorities:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implementing the SCREENSHOT action on Linux&lt;/li&gt;
&lt;li&gt;Fixing a bug with the SCREENSHOT action on Windows: it doesn't work when --fullscreen is passed to testsprite2&lt;/li&gt;
&lt;li&gt;Adding actions to inject mouse/keyboard events&lt;/li&gt;
&lt;li&gt;Adding actions to manipulate the SUT windows. E.g., minimize, maximize, resize, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;It's been a lot of fun working on this project over the summer. I'm really grateful to Andreas and the rest of the SDL community in making my first significant open source contribution a success. I plan to stay actively involved in the project and the SDL community in the future and to contribute often.&lt;/p&gt;
&lt;p&gt;Thanks for reading and goodbye!&lt;/p&gt;</summary><category term="gsoc"></category><category term="sdl"></category></entry><entry><title>GSoC 2013 Weeks 8, 9, 10 Review</title><link href="http://nerdap.github.io/gsoc-2013-weeks-7-9-10.html" rel="alternate"></link><updated>2013-08-25T22:12:00+05:30</updated><author><name>Apoorv Upreti</name></author><id>tag:nerdap.github.io,2013-08-25:gsoc-2013-weeks-7-9-10.html</id><summary type="html">&lt;p&gt;For the past three weeks I've been working on &lt;a href="https://github.com/nerdap/autotestsprite2/wiki/Product-Backlog#3-theme-action-based-testing-and-core-test"&gt;Theme 3&lt;/a&gt; which is about developing a system to read a queue of "actions" from a file and execute them. These actions are performed on the SUT process and serve as a mechanism to test the SUT and quit/kill it when necessary. As of now we have four actions - QUIT, KILL, LAUNCH and SCREENSHOT.&lt;/p&gt;
&lt;p&gt;The QUIT action is used to gracefully quit the SUT process. While this is simple to implement on Linux, on Windows there no easy way to gracefully quit. The standard procedure is to iterate through all the windows owned by the process and send WM_CLOSE messages to each of them.&lt;/p&gt;
&lt;p&gt;The KILL action is used in situations where the SUT has hung or is taking too long to quit.&lt;/p&gt;
&lt;p&gt;The LAUNCH action launches a process with a given list of command line arguments.&lt;/p&gt;
&lt;p&gt;The SCREENSHOT action takes three screenshots of each window of the SUT process. One screenshot of the entire desktop, one of the entire window and one of the window's client area. I tried various command line tools for this but none of them seemed perfect so I ended up implementing screenshot functions myself. For now this action is only supported on Windows.&lt;/p&gt;
&lt;p&gt;To get an idea of what an actions config file looks like, take a look at sample.actions.config in the project repository.&lt;/p&gt;
&lt;p&gt;With the actions system in place, theme 3 is complete. The next step is to validate the screenshots to check if SDL is rendering the content correctly. This will be a slight detour from theme 4. On Andreas' suggestion, I'm going to develop only for Windows from now on, and work on Linux after testing on Windows is complete.&lt;/p&gt;</summary><category term="gsoc"></category><category term="sdl"></category></entry><entry><title>GSoC 2013 Week 7 and Midterm Review</title><link href="http://nerdap.github.io/gsoc-2013-week-7-and-midterm-review.html" rel="alternate"></link><updated>2013-08-05T20:36:00+05:30</updated><author><name>Apoorv Upreti</name></author><id>tag:nerdap.github.io,2013-08-05:gsoc-2013-week-7-and-midterm-review.html</id><summary type="html">&lt;p&gt;Today is the last day of week 7 and the end of the first half of GSoC. It appears I have performed well enough to clear the midterm review. In this blog post I'll discuss what I've accomplished over the last seven weeks and give a short overview of the functionality so far.&lt;/p&gt;
&lt;p&gt;Andreas' suggestion was to approach the project &lt;a href="https://en.wikipedia.org/wiki/Scrum_%28development%29"&gt;SCRUM&lt;/a&gt; style, dividing entire project into a product backlog with "user stories" that described what features a user might possibly need. These user stories were grouped into five themes. The product backlog can be found &lt;a href="https://github.com/nerdap/autotestsprite2/wiki/Product-Backlog"&gt;here&lt;/a&gt;. This turned out to be very useful to stay on track and not go off on unrelated tangents. By the end of this week, I'll have finished the first two themes.&lt;/p&gt;
&lt;h3&gt;What we have so far&lt;/h3&gt;
&lt;p&gt;We've got a test harness that takes a SUT (system under test; in our case this is testsprite2) executable as a parameter along with a config file that describes the command line options that the SUT takes as input, and then launches the SUT with different combinations of the command line parameters. The SUT executable is killed automatically after a certain timeout period that can be specified while running the test harness. The exit status returned by the SUT process is checked to see if the run was a pass or a fail.&lt;/p&gt;
&lt;p&gt;An SUT config file is a CSV file where each line describes the type and range of values accepted by each SUT option. I've described the format in detail &lt;a href="https://github.com/nerdap/autotestsprite2/wiki/SUT-Command-Line-Options-Encoding"&gt;here&lt;/a&gt;. There could be merit in shifting to a more versatile format like JSON, because there are plans to add features like dependencies between parameters, short descriptions for each parameter and so on.&lt;/p&gt;
&lt;p&gt;A combination of command line parameters that is passed to the SUT is called a variation. Currently there are two schemes to generate variations - exhaustive and random. The exhaustive variation scheme in some sense runs the SUT for all possible variations that the SUT can take while the random scheme randomly generates variations. Detailed information on how these variations are generated can be found on the &lt;a href="https://github.com/nerdap/autotestsprite2/wiki/Variators"&gt;wiki page&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To check out the project so far, you can pull the &lt;a href="https://bitbucket.org/nerdap/sdlvisualtest"&gt;repository&lt;/a&gt; and build using the instructions given in the README.txt. One way to run the test harness is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;testharness&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;sutapp&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;testsprite2&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;sutconfig&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;repo&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;visualtest&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sample&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sut&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;timeout&lt;/span&gt; &lt;span class="mi"&gt;5000&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;variator&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;variations&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This runs testsprite2 using the sample configuration provided in the repository. The variations are generated randomly and the test harness quits after testing with 5 variations.&lt;/p&gt;
&lt;p&gt;For a more details on the kind of options you can pass to the test harness, launch the test harness with no parameters:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;testharness&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;With that, &lt;a href="https://github.com/nerdap/autotestsprite2/wiki/Product-Backlog#1-theme-design-and-core-infrastructure"&gt;theme 1 and 2&lt;/a&gt; are complete, and next week I'll move on to &lt;a href="https://github.com/nerdap/autotestsprite2/wiki/Product-Backlog#3-theme-action-based-testing-and-core-test"&gt;theme 3&lt;/a&gt;, where I'll work on implementing "actions" like quit process, take screenshot, and so on. A list of such actions will be loaded from a file and each action will have a specific time when it has to be executed. These actions act on the SUT to collect data for the test oracle.&lt;/p&gt;
&lt;p&gt;GSoC has been a lot of fun so far. Although I've not moved as fast as I wanted to, it is my hope that in the next half I'll make much more significant progress.&lt;/p&gt;</summary><category term="gsoc"></category><category term="sdl"></category></entry><entry><title>GSoC 2013 Weeks 5 and 6 Review</title><link href="http://nerdap.github.io/gsoc-2013-weeks-5-and-6.html" rel="alternate"></link><updated>2013-07-29T11:19:00+05:30</updated><author><name>Apoorv Upreti</name></author><id>tag:nerdap.github.io,2013-07-29:gsoc-2013-weeks-5-and-6.html</id><summary type="html">&lt;p&gt;I've been working on Theme 2 for the last two weeks, which is about varying the SUT command line options.&lt;/p&gt;
&lt;p&gt;The first task was to come up with a format to describe the options to the SUT and the kinds of input they would accept. After considering XML, JSON and CSV as possible options, I decided to go with CSV since it's easy to parse without any external dependencies. I've described the encoding in detail and also provided a sample encoding for testsprite2 on the &lt;a href="https://github.com/nerdap/autotestsprite2/wiki/SUT-Command-Line-Options-Encoding"&gt;wiki&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;Andreas suggested using SDL_RWops for reading from the CSV file instead of FILE for better compatibility with platforms like Android. This created a bit of a problem because the SDL_RWops library doesn't have an equivalent for fgets(). I had to implement a ReadLine() function using SDL_RWread() which proved to be an interesting exercise.&lt;/p&gt;
&lt;p&gt;The CSV file is parsed into a struct that is used by "variators" to generate variations of SUT command line options. The test harness tests the SUT with each such variation.&lt;/p&gt;
&lt;p&gt;A variator is quite simply an iterator that iterates through different variations of command line options. I've written briefly about variators in the &lt;a href="https://github.com/nerdap/autotestsprite2/wiki/Variators"&gt;wiki&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The test harness will call the variator, launch the SUT with the arguments string from the variator, wait for a specified time period, then kill the SUT and report its return code. This process is repeated until there are no more variations left.&lt;/p&gt;
&lt;p&gt;With this part done by the end week 7, we will have a base for the testing framework. The next step would be to add the ability to inject actions while the SUT is running; to take a screenshot or click a mouse button, for example.&lt;/p&gt;</summary><category term="gsoc"></category><category term="sdl"></category></entry><entry><title>GSoC 2013 Weeks 3 and 4 Review</title><link href="http://nerdap.github.io/gsoc-2013-weeks-3-and-4.html" rel="alternate"></link><updated>2013-07-08T22:23:00+05:30</updated><author><name>Apoorv Upreti</name></author><id>tag:nerdap.github.io,2013-07-08:gsoc-2013-weeks-3-and-4.html</id><summary type="html">&lt;p&gt;I wasn't able to post my updates last week, so I'm going to bunch them together with this week's updates.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The build system for Linux is now ready. The setup I'd made in week 2 didn't compile on Cygwin and MingW because I hadn't used the output from sdl2-config to configure the library paths and compiler flags. After some help from the SDL wiki and some Googling on my own I managed to configure autotools to use sdl2-config correctly. I haven't been able to test the new setup on Cygwin/MinGW yet but it works just fine on Ubuntu and Linux Mint.&lt;/li&gt;
&lt;li&gt;I've implemented the process API for Linux.&lt;/li&gt;
&lt;li&gt;Implemented parsing for arguments passed to the test harness and for config files. The way this works is quite similar to the way SDLTest_CommonArg() works.&lt;/li&gt;
&lt;li&gt;Implemented a tokenizer to break the arguments string to the SUT into an argv-style array. This was required because all the calls in the exec() family expect a list of arguments while Windows' CreateProcess() expects a single arguments string.&lt;/li&gt;
&lt;li&gt;Added a timer to kill the SUT after a maximum timeout.&lt;/li&gt;
&lt;li&gt;I've started working on parsing a config file that describes what kind of options an SUT application can take. The idea so far is that the file will be represented in JSON where each option will be a JSON object. JSON is an ideal choice because it's easy to write, light weight and easy to parse.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This week I completed the design and core infrastructure theme and began work on the next one, which deals with varying the SUT command line options.&lt;/p&gt;</summary><category term="gsoc"></category><category term="sdl"></category></entry><entry><title>GSoC 2013 Week 2 Review</title><link href="http://nerdap.github.io/gsoc-2013-week-2.html" rel="alternate"></link><updated>2013-07-02T18:23:00+05:30</updated><author><name>Apoorv Upreti</name></author><id>tag:nerdap.github.io,2013-07-02:gsoc-2013-week-2.html</id><summary type="html">&lt;p&gt;Last week I set up a basic API for launching and terminating processes on Windows. The API so far consists of just three functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SDL_LaunchProcess():&lt;/strong&gt; Launches a process with some command line arguments.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SDL_IsProcessRunning():&lt;/strong&gt; Checks if a process is running or not.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SDL_KillProcess():&lt;/strong&gt; Kills the specified process.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I also had to get a build setup working on Linux using autotools. It wasn't easy getting started - good tutorials that started from the basics were hard to find. The best resource I found was a &lt;a href="http://www.lrde.epita.fr/~adl/autotools.html"&gt;set of slides&lt;/a&gt; by Alexandre Duret-Lutz. I did get a build setup working in end, although I'll have to get some expert advice on it to make sure it's acceptable.&lt;/p&gt;
&lt;p&gt;I've added doxygen documentation for functions and structs in the current API.&lt;/p&gt;
&lt;p&gt;One issue to think about:&lt;/p&gt;
&lt;p&gt;At least on Linux, PIDs can be reused. So IsProcessRunning() can report a process as running while in fact the process may have terminated a while back and a different process with the same PID may have taken its place. I'm not sure if this is a situation that I'll run into often enough for it to warrant fixing.&lt;/p&gt;
&lt;p&gt;Next steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implement process API for Linux.&lt;/li&gt;
&lt;li&gt;Implement parsing command line parameters to the testharness.&lt;/li&gt;
&lt;li&gt;Implement loading these command line parameters from a config file.&lt;/li&gt;
&lt;li&gt;Timed quit for the SUT.&lt;/li&gt;
&lt;/ul&gt;</summary><category term="gsoc"></category><category term="sdl"></category></entry><entry><title>GSoC 2013 Week 1 Review</title><link href="http://nerdap.github.io/gsoc-2013-week-1.html" rel="alternate"></link><updated>2013-06-23T22:16:00+05:30</updated><author><name>Apoorv Upreti</name></author><id>tag:nerdap.github.io,2013-06-23:gsoc-2013-week-1.html</id><summary type="html">&lt;p&gt;At the end of the community bonding period, Andreas and I went through the product backlog, adding demoables, sizing and reordering items, and adding and reorganizing themes. It was an interesting exercise because it helped me fully understand the complexity of the project and plan my future weeks better.&lt;/p&gt;
&lt;p&gt;And so began the GSoC coding period. The first theme I'm working on concerns the design and core infrastructure of the new visual test system. I didn't make as much progress as I wanted to this week but I feel it's a reasonable start.&lt;/p&gt;
&lt;p&gt;Progress so far:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Product backlog is &lt;a href="https://github.com/nerdap/autotestsprite2/wiki/Product-Backlog"&gt;up&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Set up a Bitbucket &lt;a href="https://bitbucket.org/nerdap/sdlvisualtest"&gt;repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A &lt;a href="https://github.com/nerdap/autotestsprite2/wiki/Test-system-design"&gt;design document&lt;/a&gt; is ready, but it's still a work in progress. I'll be adding more details soon.&lt;/li&gt;
&lt;li&gt;Wrote a simple test harness for windows that launches a process (passed as a command line parameter) and returns the exit code.&lt;/li&gt;
&lt;li&gt;Created a Visual Studio 2012 solution to build the project; makefiles are coming soon.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What's next?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Make/Configure scripts so we can build on Linux.&lt;/li&gt;
&lt;li&gt;Adding a Doxygen make target.&lt;/li&gt;
&lt;li&gt;Adding Linux support in the test harness.&lt;/li&gt;
&lt;li&gt;Updating the design document with more details.&lt;/li&gt;
&lt;/ul&gt;</summary><category term="gsoc"></category><category term="sdl"></category></entry><entry><title>Google Summer of Code 2013 under SDL</title><link href="http://nerdap.github.io/gsoc-2013-sdl.html" rel="alternate"></link><updated>2013-06-10T17:00:00+05:30</updated><author><name>Apoorv Upreti</name></author><id>tag:nerdap.github.io,2013-06-10:gsoc-2013-sdl.html</id><summary type="html">&lt;p&gt;SDL or Simple DirectMedia Layer is a low-level, cross-platform multimedia library that provides access to keyboard, mouse, audio and video hardware. It's available for Windows, Linux, OS X, iOS, Android, and many other platforms.&lt;/p&gt;
&lt;p&gt;My GSoC project concerns a test in the SDL test suite called testsprite2. This test simply launches a window and moves sprites around the screen as fast as possible. The basic objective of the test is to answer three questions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Is the window being created by the window manager as expected? (correct title, resolution, window state, etc.)&lt;/li&gt;
&lt;li&gt;Is mouse behavior being detected correctly?&lt;/li&gt;
&lt;li&gt;Are the sprites inside the window rendered correctly?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The goal of this GSoC project is to automate this process. There are two major challenges to overcome. Firstly, testsprite2 takes 26 parameters as input with thousands of valid combinations. Success would mean testing as many valid combinations as possible. Secondly, verifying the success of the test is inherently hard to automate - it's much easier for a human to answer the above questions than for a computer to. By automating testsprite2, I hope to make it easier to detect certain kinds of bugs in SDL's code, ones that were missed out previously.&lt;/p&gt;
&lt;p&gt;I started using SDL years ago when I was still in high school. I fondly remember following lazy_foo's tutorials and struggling with concepts like blitting, double buffering and alpha blending. This is why the opportunity to make SDL better means a lot to me. I'm looking forward to working towards a top quality SDL 2.0 release this summer.&lt;/p&gt;
&lt;p&gt;Useful Links:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.libsdl.org/gsoc.php" title="SDL GSoC Ideas Page"&gt;GSoC Ideas Page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/nerdap/autotestsprite2/wiki" title="Project Wiki on GitHub"&gt;Project Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.google-melange.com/gsoc/proposal/review/google/gsoc2013/nerdap/10001" title="Application on Melange"&gt;Application on Melange&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="gsoc"></category><category term="sdl"></category></entry></feed>